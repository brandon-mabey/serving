// +build e2e

/*
Copyright 2019 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package conformance

import (
	pkgTest "github.com/knative/pkg/test"
	"github.com/knative/serving/pkg/apis/serving/v1alpha1"
	rtesting "github.com/knative/serving/pkg/reconciler/v1alpha1/testing"
	"github.com/knative/serving/test"
	"net/http"
	"strings"
	"testing"
)

func setServiceGenerateName(generateName string) rtesting.ServiceOption {
	return func(service *v1alpha1.Service) {
		service.ObjectMeta.GenerateName = generateName
	}
}

func setConfigurationGenerateName(generateName string) rtesting.ConfigOption {
	return func(config *v1alpha1.Configuration) {
		config.ObjectMeta.GenerateName = generateName
	}
}

func setRouteGenerateName(generateName string) rtesting.RouteOption {
	return func(route *v1alpha1.Route) {
		route.ObjectMeta.GenerateName = generateName
	}
}

// getGenerateNamePrefix returns the object name to be used for testing, shorted to
// 44 characters to avoid #3236, as generateNames longer than 44 characters may cause
// some knative resources to never become ready.
func getGenerateNamePrefix(t *testing.T) string {
	generateName := test.ObjectNameForTest(t) + "-"

	generateNameLength := len(generateName)
	if generateNameLength > 44 {
		generateNameLength = 44
	}
	return generateName[0:generateNameLength]
}

func ensureCanServeRequests(t *testing.T, clients *test.Clients, route *v1alpha1.Route) {
	t.Logf("Route %s has a domain set in its status", route.Name)
	var domain string
	err := test.WaitForRouteState(
		clients.ServingClient,
		route.Name,
		func(r *v1alpha1.Route) (bool, error) {
			domain = r.Status.Domain
			return domain != "", nil
		},
		"RouteDomain",
	)

	t.Logf("Route %s can serve the expected data at the endpoint", route.Name)
	_, err = pkgTest.WaitForEndpointState(
		clients.KubeClient,
		t.Logf,
		domain,
		pkgTest.Retrying(pkgTest.EventuallyMatchesBody(helloWorldText), http.StatusNotFound),
		"WaitForEndpointToServeText",
		test.ServingFlags.ResolvableDomain)
	if err != nil {
		t.Fatalf("The endpoint for Route %s at domain %s didn't serve the expected text \"%s\": %v", route.Name, domain, helloWorldText, err)
	}

}

// TestServiceGenerateName checks that knative Services MAY request names generated by
// the system using metadata.generateName. It ensures that knative Services created this way can become ready
// and serve requests.
func TestServiceGenerateName(t *testing.T) {
	t.Parallel()
	clients := setup(t)

	generateName := getGenerateNamePrefix(t)
	names := test.ResourceNames{
		Image: helloworld,
	}

	// Cleanup on test failure.
	test.CleanupOnInterrupt(func() { test.TearDown(clients, names) })
	defer func() { test.TearDown(clients, names) }()

	// Create the service using the generate name field. If the serivce does not become ready this will fail.
	t.Logf("Creating new service with generateName %s", generateName)
	resources, err := test.CreateRunLatestServiceReady(t, clients, &names, &test.Options{}, setServiceGenerateName(generateName))
	if err != nil {
		t.Fatalf("Failed to create service with generateName %s: %v", generateName, err)
	}

	// Ensure that the name given to the service is generated from the generateName field.
	t.Log("When the service is created, the name is generated using the provided generateName")
	if names.Service == generateName {
		t.Fatalf("Service did not recieve a randomized name, instead got %s", names.Service)
	}
	if !strings.HasPrefix(names.Service, generateName) {
		t.Fatalf("Service name is not prefixed by the generateName field, expected %s to be a prefix, got %s", generateName, names.Service)
	}

	// Ensure that the service can serve requests
	ensureCanServeRequests(t, clients, resources.Route)
}

// TestRouteAndConfiguration checks that both routes and configurations MAY request names generated by
// the system using metadata.generateName. It ensures that routes and configurations created this way both:
// 1. Become ready
// 2. Can serve requests.
func TestRouteAndConfigurationGenerateName(t *testing.T) {
	t.Parallel()
	clients := setup(t)

	generateName := getGenerateNamePrefix(t)
	names := test.ResourceNames{
		Image: helloworld,
	}

	test.CleanupOnInterrupt(func() { test.TearDown(clients, names) })
	defer func() { test.TearDown(clients, names) }()

	t.Logf("Creating new configuration with generateName %s", generateName)
	config, err := test.CreateConfiguration(t, clients, names, &test.Options{}, setConfigurationGenerateName(generateName))
	if err != nil {
		t.Fatalf("Failed to create configuration with generateName %s: %v", generateName, err)
	}
	names.Config = config.Name

	// Ensure the associated revision is created. This also checks that the configuration becomes ready.
	t.Log("The configuration will be updated with the name of the associated Revision once it is created.")
	names.Revision, err = test.WaitForConfigLatestRevision(clients, names)
	if err != nil {
		t.Fatalf("Configuration %s was not updated with the new revision: %v", names.Config, err)
	}

	// Ensure that the name given to the configuration is generated from the generate name field.
	t.Log("When the configuration is created, the name is generated using the provided generateName")
	if names.Config == generateName {
		t.Fatalf("Configuration did not recieve a randomized name, instead got %s", names.Config)
	}
	if !strings.HasPrefix(names.Config, generateName) {
		t.Fatalf("Configuration name is not prefixed by the generateName field, expected %s to be a prefix, got %s", generateName, names.Config)
	}

	// Create a route that maps to the revision created by the configuration above
	t.Logf("Create new Route with generateName %s", generateName)
	route, err := test.CreateRoute(t, clients, names, setRouteGenerateName(generateName))
	if err != nil {
		t.Fatalf("Failed to create route with generateName %s: %v", generateName, err)
	}
	names.Route = route.Name

	t.Log("When the route is created, it will become ready")
	if err := test.WaitForRouteState(clients.ServingClient, names.Route, test.IsRouteReady, "RouteIsReady"); err != nil {
		t.Fatalf("Error waiting for the route %s to become ready: %v", names.Route, err)
	}

	// Ensure that the name given to the route is generated from the generate name field
	if names.Route == generateName {
		t.Fatalf("Route did not recieve a randomized name, instead got %s", names.Route)
	}
	if !strings.HasPrefix(names.Route, generateName) {
		t.Fatalf("Route name is not prefixed by the generateName field, expected %s to be a prefix, got %s", generateName, names.Route)
	}

	// Ensure that the generated route endpoint can serve requests
	ensureCanServeRequests(t, clients, route)
}
